package arrow

import (
	"github.com/influxdata/arrow/memory"
)

{{range .}}

type {{.Name}}ArrayBuilder struct {
	arrayBuilder

{{if .Opt.Parametric -}}
	typE    *{{.Name}}Type
{{end -}}
	data    *memory.PoolBuffer
	rawData []{{.Type}}
}

{{if .Opt.Parametric}}
func New{{.Name}}ArrayBuilder(pool memory.Allocator, typE *{{.Name}}Type) *{{.Name}}ArrayBuilder {
	return &{{.Name}}ArrayBuilder{arrayBuilder: arrayBuilder{pool: pool}, typE: typE}
}
{{else}}
func New{{.Name}}ArrayBuilder(pool memory.Allocator) *{{.Name}}ArrayBuilder {
	return &{{.Name}}ArrayBuilder{arrayBuilder: arrayBuilder{pool: pool}}
}
{{end}}

func (b *{{.Name}}ArrayBuilder) Append(v {{.Type}}) {
	b.Reserve(1)
	b.UnsafeAppend(v)
}

func (b *{{.Name}}ArrayBuilder) AppendNull() {
	b.Reserve(1)
	b.UnsafeAppendBoolToBitmap(false)
}

func (b *{{.Name}}ArrayBuilder) UnsafeAppend(v {{.Type}}) {
	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
	b.rawData[b.length] = v
	b.length++
}

func (b *{{.Name}}ArrayBuilder) UnsafeAppendBoolToBitmap(isValid bool) {
	if isValid {
		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
	} else {
		b.nullN++
	}
	b.length++
}

// AppendValues will append the values in the v slice. The valid slice determines which values
// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
// all values in v are appended and considered valid.
func (b *{{.Name}}ArrayBuilder) AppendValues(v []{{.Type}}, valid []bool) {
	if len(v) != len(valid) && len(valid) != 0 {
		panic("len(v) != len(valid) && len(valid) != 0")
	}

	b.Reserve(len(v))
	if len(v) > 0 {
		{{.Name}}Traits{}.Copy(b.rawData[b.length:], v)
	}
	b.arrayBuilder.unsafeAppendBoolsToBitmap(valid, len(v))
}

func (b *{{.Name}}ArrayBuilder) Init(capacity int) {
	b.arrayBuilder.init(capacity)

	b.data = memory.NewPoolBuffer(b.pool)
	bytesN := {{.Name}}Traits{}.BytesRequired(capacity)
	b.data.Resize(bytesN)
	b.rawData = {{.Name}}Traits{}.CastFromBytes(b.data.Bytes())
}

// Reserve ensures there is enough space for adding the specified number of elements
// by checking the capacity and calling Resize if necessary.
func (b *{{.Name}}ArrayBuilder) Reserve(elements int) {
	b.arrayBuilder.reserve(elements, b.Resize)
}

func (b *{{.Name}}ArrayBuilder) Resize(capacity int) {
	if capacity < minBuilderCapacity {
		capacity = minBuilderCapacity
	}

	if b.capacity == 0 {
		b.Init(capacity)
	} else {
		b.arrayBuilder.resize(capacity, b.Init)
		b.data.Resize({{.Name}}Traits{}.BytesRequired(capacity))
		b.rawData = {{.Name}}Traits{}.CastFromBytes(b.data.Bytes())
	}
}

func (b *{{.Name}}ArrayBuilder) Finish() *{{.Name}}Array {
	data := b.finishInternal()
	return New{{.Name}}Array(data)
}

func (b *{{.Name}}ArrayBuilder) finishInternal() *ArrayData {
	bytesRequired := {{.Name}}Traits{}.BytesRequired(b.length)
	if bytesRequired > 0 && bytesRequired < b.data.Len() {
		// trim buffers
		b.data.Resize(bytesRequired)
	}
{{if .Opt.Parametric -}}
	res := NewArrayData(b.typE, b.length, []*memory.Buffer{&b.nullBitmap.Buffer, &b.data.Buffer}, b.nullN)
{{else -}}
	res := NewArrayData(PrimitiveTypes.{{.Name}}, b.length, []*memory.Buffer{&b.nullBitmap.Buffer, &b.data.Buffer}, b.nullN)
{{end -}}
	b.reset()

	return res
}
{{end}}