// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: array_primitive.gen.go.tmpl

package arrow

import (
	"reflect"
	"unsafe"
)

// Primitive Array types

type Int64Array struct {
	data            *ArrayData
	nullBitmapBytes []byte
	values          []int64
}

func NewInt64Array(data *ArrayData) *Int64Array {
	a := &Int64Array{}
	a.setData(data)
	return a
}

func (a *Int64Array) DataType() DataType      { return a.data.typE }
func (a *Int64Array) NullN() int              { return a.data.nullN }
func (a *Int64Array) NullBitmapBytes() []byte { return a.nullBitmapBytes }
func (a *Int64Array) Int64Values() []int64    { return a.values }
func (a *Int64Array) Data() *ArrayData        { return a.data }
func (a *Int64Array) Len() int                { return a.data.length }

// IsNull returns true if value at index is null. Does not check bounds.
func (a *Int64Array) IsNull(i int) bool {
	return len(a.nullBitmapBytes) != 0 && bitIsNotSet(a.nullBitmapBytes, i)
}

// IsValid returns true if value at index is not null. Does not check bounds.
func (a *Int64Array) IsValid(i int) bool {
	return len(a.nullBitmapBytes) == 0 || bitIsSet(a.nullBitmapBytes, i)
}

func (a *Int64Array) arraySetData(data *ArrayData) {
	if len(data.buffers) > 0 && data.buffers[0] != nil {
		a.nullBitmapBytes = data.buffers[0].Bytes()
	}
	a.data = data
}

func (a *Int64Array) setData(data *ArrayData) {
	a.arraySetData(data)
	vals := data.buffers[1]
	if vals != nil {
		a.values = Int64Traits{}.CastFromBytes(vals.Bytes())
	}
}

// Int64 traits

const (
	int64SizeBytes = int(unsafe.Sizeof(int64(0)))
)

type Int64Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (Int64Traits) BytesRequired(elements int) int { return int64SizeBytes * elements }

func (Int64Traits) CastFromBytes(b []byte) []int64 {
	s := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&b[0])),
		Len:  len(b) / int64SizeBytes,
		Cap:  cap(b) / int64SizeBytes,
	}

	return *(*[]int64)(unsafe.Pointer(&s))
}

func (Int64Traits) CastToBytes(b []int64) []byte {
	s := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&b[0])),
		Len:  len(b) * int64SizeBytes,
		Cap:  cap(b) * int64SizeBytes,
	}

	return *(*[]byte)(unsafe.Pointer(&s))
}

func (t Int64Traits) Copy(dst, src []int64) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}

type Uint64Array struct {
	data            *ArrayData
	nullBitmapBytes []byte
	values          []uint64
}

func NewUint64Array(data *ArrayData) *Uint64Array {
	a := &Uint64Array{}
	a.setData(data)
	return a
}

func (a *Uint64Array) DataType() DataType      { return a.data.typE }
func (a *Uint64Array) NullN() int              { return a.data.nullN }
func (a *Uint64Array) NullBitmapBytes() []byte { return a.nullBitmapBytes }
func (a *Uint64Array) Uint64Values() []uint64  { return a.values }
func (a *Uint64Array) Data() *ArrayData        { return a.data }
func (a *Uint64Array) Len() int                { return a.data.length }

// IsNull returns true if value at index is null. Does not check bounds.
func (a *Uint64Array) IsNull(i int) bool {
	return len(a.nullBitmapBytes) != 0 && bitIsNotSet(a.nullBitmapBytes, i)
}

// IsValid returns true if value at index is not null. Does not check bounds.
func (a *Uint64Array) IsValid(i int) bool {
	return len(a.nullBitmapBytes) == 0 || bitIsSet(a.nullBitmapBytes, i)
}

func (a *Uint64Array) arraySetData(data *ArrayData) {
	if len(data.buffers) > 0 && data.buffers[0] != nil {
		a.nullBitmapBytes = data.buffers[0].Bytes()
	}
	a.data = data
}

func (a *Uint64Array) setData(data *ArrayData) {
	a.arraySetData(data)
	vals := data.buffers[1]
	if vals != nil {
		a.values = Uint64Traits{}.CastFromBytes(vals.Bytes())
	}
}

// Uint64 traits

const (
	uint64SizeBytes = int(unsafe.Sizeof(uint64(0)))
)

type Uint64Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (Uint64Traits) BytesRequired(elements int) int { return uint64SizeBytes * elements }

func (Uint64Traits) CastFromBytes(b []byte) []uint64 {
	s := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&b[0])),
		Len:  len(b) / uint64SizeBytes,
		Cap:  cap(b) / uint64SizeBytes,
	}

	return *(*[]uint64)(unsafe.Pointer(&s))
}

func (Uint64Traits) CastToBytes(b []uint64) []byte {
	s := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&b[0])),
		Len:  len(b) * uint64SizeBytes,
		Cap:  cap(b) * uint64SizeBytes,
	}

	return *(*[]byte)(unsafe.Pointer(&s))
}

func (t Uint64Traits) Copy(dst, src []uint64) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}

type Float64Array struct {
	data            *ArrayData
	nullBitmapBytes []byte
	values          []float64
}

func NewFloat64Array(data *ArrayData) *Float64Array {
	a := &Float64Array{}
	a.setData(data)
	return a
}

func (a *Float64Array) DataType() DataType       { return a.data.typE }
func (a *Float64Array) NullN() int               { return a.data.nullN }
func (a *Float64Array) NullBitmapBytes() []byte  { return a.nullBitmapBytes }
func (a *Float64Array) Float64Values() []float64 { return a.values }
func (a *Float64Array) Data() *ArrayData         { return a.data }
func (a *Float64Array) Len() int                 { return a.data.length }

// IsNull returns true if value at index is null. Does not check bounds.
func (a *Float64Array) IsNull(i int) bool {
	return len(a.nullBitmapBytes) != 0 && bitIsNotSet(a.nullBitmapBytes, i)
}

// IsValid returns true if value at index is not null. Does not check bounds.
func (a *Float64Array) IsValid(i int) bool {
	return len(a.nullBitmapBytes) == 0 || bitIsSet(a.nullBitmapBytes, i)
}

func (a *Float64Array) arraySetData(data *ArrayData) {
	if len(data.buffers) > 0 && data.buffers[0] != nil {
		a.nullBitmapBytes = data.buffers[0].Bytes()
	}
	a.data = data
}

func (a *Float64Array) setData(data *ArrayData) {
	a.arraySetData(data)
	vals := data.buffers[1]
	if vals != nil {
		a.values = Float64Traits{}.CastFromBytes(vals.Bytes())
	}
}

// Float64 traits

const (
	float64SizeBytes = int(unsafe.Sizeof(float64(0)))
)

type Float64Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (Float64Traits) BytesRequired(elements int) int { return float64SizeBytes * elements }

func (Float64Traits) CastFromBytes(b []byte) []float64 {
	s := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&b[0])),
		Len:  len(b) / float64SizeBytes,
		Cap:  cap(b) / float64SizeBytes,
	}

	return *(*[]float64)(unsafe.Pointer(&s))
}

func (Float64Traits) CastToBytes(b []float64) []byte {
	s := reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(&b[0])),
		Len:  len(b) * float64SizeBytes,
		Cap:  cap(b) * float64SizeBytes,
	}

	return *(*[]byte)(unsafe.Pointer(&s))
}

func (t Float64Traits) Copy(dst, src []float64) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}
