// Code generated by type_traits_numeric.gen.go.tmpl.
// DO NOT EDIT.

package arrow

import (
	"encoding/binary"
	"reflect"
	"unsafe"
)

var (
	Int32Traits     int32Traits
	Int64Traits     int64Traits
	Uint64Traits    uint64Traits
	Float64Traits   float64Traits
	TimestampTraits timestampTraits
)

// Int32 traits

const (
	// Int32SizeBytes specifies the number of bytes required to store a single int32 in memory
	Int32SizeBytes = int(unsafe.Sizeof(int32(0)))
)

type int32Traits struct{}

// BytesRequired returns the number of bytes required to store n elements in memory.
func (int32Traits) BytesRequired(n int) int { return Int32SizeBytes * n }

// PutValue
func (int32Traits) PutValue(b []byte, v int32) {
	binary.LittleEndian.PutUint32(b, uint32(v))
}

// CastFromBytes reinterprets the slice b to a slice of type int32.
//
// NOTE: len(b) must be a multiple of Int32SizeBytes.
func (int32Traits) CastFromBytes(b []byte) []int32 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []int32
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Int32SizeBytes
	s.Cap = h.Cap / Int32SizeBytes

	return res
}

// CastToBytes reinterprets the slice b to a slice of bytes.
func (int32Traits) CastToBytes(b []int32) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Int32SizeBytes
	s.Cap = h.Cap * Int32SizeBytes

	return res
}

// Copy copies src to dst.
func (int32Traits) Copy(dst, src []int32) { copy(dst, src) }

// Int64 traits

const (
	// Int64SizeBytes specifies the number of bytes required to store a single int64 in memory
	Int64SizeBytes = int(unsafe.Sizeof(int64(0)))
)

type int64Traits struct{}

// BytesRequired returns the number of bytes required to store n elements in memory.
func (int64Traits) BytesRequired(n int) int { return Int64SizeBytes * n }

// PutValue
func (int64Traits) PutValue(b []byte, v int64) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

// CastFromBytes reinterprets the slice b to a slice of type int64.
//
// NOTE: len(b) must be a multiple of Int64SizeBytes.
func (int64Traits) CastFromBytes(b []byte) []int64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []int64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Int64SizeBytes
	s.Cap = h.Cap / Int64SizeBytes

	return res
}

// CastToBytes reinterprets the slice b to a slice of bytes.
func (int64Traits) CastToBytes(b []int64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Int64SizeBytes
	s.Cap = h.Cap * Int64SizeBytes

	return res
}

// Copy copies src to dst.
func (int64Traits) Copy(dst, src []int64) { copy(dst, src) }

// Uint64 traits

const (
	// Uint64SizeBytes specifies the number of bytes required to store a single uint64 in memory
	Uint64SizeBytes = int(unsafe.Sizeof(uint64(0)))
)

type uint64Traits struct{}

// BytesRequired returns the number of bytes required to store n elements in memory.
func (uint64Traits) BytesRequired(n int) int { return Uint64SizeBytes * n }

// PutValue
func (uint64Traits) PutValue(b []byte, v uint64) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

// CastFromBytes reinterprets the slice b to a slice of type uint64.
//
// NOTE: len(b) must be a multiple of Uint64SizeBytes.
func (uint64Traits) CastFromBytes(b []byte) []uint64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []uint64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Uint64SizeBytes
	s.Cap = h.Cap / Uint64SizeBytes

	return res
}

// CastToBytes reinterprets the slice b to a slice of bytes.
func (uint64Traits) CastToBytes(b []uint64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Uint64SizeBytes
	s.Cap = h.Cap * Uint64SizeBytes

	return res
}

// Copy copies src to dst.
func (uint64Traits) Copy(dst, src []uint64) { copy(dst, src) }

// Float64 traits

const (
	// Float64SizeBytes specifies the number of bytes required to store a single float64 in memory
	Float64SizeBytes = int(unsafe.Sizeof(float64(0)))
)

type float64Traits struct{}

// BytesRequired returns the number of bytes required to store n elements in memory.
func (float64Traits) BytesRequired(n int) int { return Float64SizeBytes * n }

// PutValue
func (float64Traits) PutValue(b []byte, v float64) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

// CastFromBytes reinterprets the slice b to a slice of type float64.
//
// NOTE: len(b) must be a multiple of Float64SizeBytes.
func (float64Traits) CastFromBytes(b []byte) []float64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []float64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Float64SizeBytes
	s.Cap = h.Cap / Float64SizeBytes

	return res
}

// CastToBytes reinterprets the slice b to a slice of bytes.
func (float64Traits) CastToBytes(b []float64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Float64SizeBytes
	s.Cap = h.Cap * Float64SizeBytes

	return res
}

// Copy copies src to dst.
func (float64Traits) Copy(dst, src []float64) { copy(dst, src) }

// Timestamp traits

const (
	// TimestampSizeBytes specifies the number of bytes required to store a single Timestamp in memory
	TimestampSizeBytes = int(unsafe.Sizeof(Timestamp(0)))
)

type timestampTraits struct{}

// BytesRequired returns the number of bytes required to store n elements in memory.
func (timestampTraits) BytesRequired(n int) int { return TimestampSizeBytes * n }

// PutValue
func (timestampTraits) PutValue(b []byte, v Timestamp) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

// CastFromBytes reinterprets the slice b to a slice of type Timestamp.
//
// NOTE: len(b) must be a multiple of TimestampSizeBytes.
func (timestampTraits) CastFromBytes(b []byte) []Timestamp {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []Timestamp
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / TimestampSizeBytes
	s.Cap = h.Cap / TimestampSizeBytes

	return res
}

// CastToBytes reinterprets the slice b to a slice of bytes.
func (timestampTraits) CastToBytes(b []Timestamp) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * TimestampSizeBytes
	s.Cap = h.Cap * TimestampSizeBytes

	return res
}

// Copy copies src to dst.
func (timestampTraits) Copy(dst, src []Timestamp) { copy(dst, src) }
