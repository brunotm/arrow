// Code generated by type_traits_numeric.gen.go.tmpl.
// DO NOT EDIT.

package arrow

import (
	"encoding/binary"
	"reflect"
	"unsafe"
)

// Int32 traits

const (
	Int32SizeBytes = int(unsafe.Sizeof(int32(0)))
)

type Int32Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (t Int32Traits) BytesRequired(elements int) int { return Int32SizeBytes * elements }

func (t Int32Traits) PutValue(b []byte, v int32) {
	binary.LittleEndian.PutUint32(b, uint32(v))
}

func (t Int32Traits) CastFromBytes(b []byte) []int32 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []int32
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Int32SizeBytes
	s.Cap = h.Cap / Int32SizeBytes

	return res
}

func (t Int32Traits) CastToBytes(b []int32) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Int32SizeBytes
	s.Cap = h.Cap * Int32SizeBytes

	return res
}

func (t Int32Traits) Copy(dst, src []int32) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}

// Int64 traits

const (
	Int64SizeBytes = int(unsafe.Sizeof(int64(0)))
)

type Int64Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (t Int64Traits) BytesRequired(elements int) int { return Int64SizeBytes * elements }

func (t Int64Traits) PutValue(b []byte, v int64) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

func (t Int64Traits) CastFromBytes(b []byte) []int64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []int64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Int64SizeBytes
	s.Cap = h.Cap / Int64SizeBytes

	return res
}

func (t Int64Traits) CastToBytes(b []int64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Int64SizeBytes
	s.Cap = h.Cap * Int64SizeBytes

	return res
}

func (t Int64Traits) Copy(dst, src []int64) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}

// Uint64 traits

const (
	Uint64SizeBytes = int(unsafe.Sizeof(uint64(0)))
)

type Uint64Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (t Uint64Traits) BytesRequired(elements int) int { return Uint64SizeBytes * elements }

func (t Uint64Traits) PutValue(b []byte, v uint64) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

func (t Uint64Traits) CastFromBytes(b []byte) []uint64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []uint64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Uint64SizeBytes
	s.Cap = h.Cap / Uint64SizeBytes

	return res
}

func (t Uint64Traits) CastToBytes(b []uint64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Uint64SizeBytes
	s.Cap = h.Cap * Uint64SizeBytes

	return res
}

func (t Uint64Traits) Copy(dst, src []uint64) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}

// Float64 traits

const (
	Float64SizeBytes = int(unsafe.Sizeof(float64(0)))
)

type Float64Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (t Float64Traits) BytesRequired(elements int) int { return Float64SizeBytes * elements }

func (t Float64Traits) PutValue(b []byte, v float64) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

func (t Float64Traits) CastFromBytes(b []byte) []float64 {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []float64
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / Float64SizeBytes
	s.Cap = h.Cap / Float64SizeBytes

	return res
}

func (t Float64Traits) CastToBytes(b []float64) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * Float64SizeBytes
	s.Cap = h.Cap * Float64SizeBytes

	return res
}

func (t Float64Traits) Copy(dst, src []float64) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}

// Timestamp traits

const (
	TimestampSizeBytes = int(unsafe.Sizeof(Timestamp(0)))
)

type TimestampTraits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func (t TimestampTraits) BytesRequired(elements int) int { return TimestampSizeBytes * elements }

func (t TimestampTraits) PutValue(b []byte, v Timestamp) {
	binary.LittleEndian.PutUint64(b, uint64(v))
}

func (t TimestampTraits) CastFromBytes(b []byte) []Timestamp {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []Timestamp
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len / TimestampSizeBytes
	s.Cap = h.Cap / TimestampSizeBytes

	return res
}

func (t TimestampTraits) CastToBytes(b []Timestamp) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len * TimestampSizeBytes
	s.Cap = h.Cap * TimestampSizeBytes

	return res
}

func (t TimestampTraits) Copy(dst, src []Timestamp) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}
