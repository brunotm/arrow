package arrow

import (
	"encoding/binary"
	"reflect"
	"unsafe"
)

{{range .}}
// {{.Name}} traits

const (
	{{.name}}SizeBytes = int(unsafe.Sizeof({{.Type}}({{.Default}})))
)

type {{.Name}}Traits struct{}

// BytesRequired returns the number of bytes required to store the requested number of elements.
func ({{.Name}}Traits) BytesRequired(elements int) int { return {{.name}}SizeBytes * elements }

func ({{.Name}}Traits) PutValue(b []byte, v {{.Type}}) {
{{- if eq .Size "1" -}}
	b[0] = v
{{- else if eq .Size "2" -}}
	binary.LittleEndian.PutUint16(b, uint16(v))
{{- else if eq .Size "4" -}}
	binary.LittleEndian.PutUint32(b, uint32(v))
{{- else if eq .Size "8" -}}
	binary.LittleEndian.PutUint64(b, uint64(v))
{{- else -}}
	panic("invalid type {{.Type}}")
{{end}}
}

func ({{.Name}}Traits) CastFromBytes(b []byte) []{{.Type}} {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []{{.Type}}
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len/{{.name}}SizeBytes
	s.Cap = h.Cap/{{.name}}SizeBytes

	return res
}

func ({{.Name}}Traits) CastToBytes(b []{{.Type}}) []byte {
	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))

	var res []byte
	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
	s.Data = h.Data
	s.Len = h.Len*{{.name}}SizeBytes
	s.Cap = h.Cap*{{.name}}SizeBytes

	return res
}

func (t {{.Name}}Traits) Copy(dst, src []{{.Type}}) {
	dstB, srcB := t.CastToBytes(dst), t.CastToBytes(src)
	copy(dstB, srcB)
}
{{end}}