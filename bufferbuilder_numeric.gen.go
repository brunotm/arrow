// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: bufferbuilder_numeric.gen.go.tmpl

package arrow

import "github.com/influxdata/arrow/memory"

// Numeric Array types

type Int32BufferBuilder struct {
	bufferBuilder
}

func NewInt32BufferBuilder(pool memory.Allocator) *Int32BufferBuilder {
	return &Int32BufferBuilder{bufferBuilder: bufferBuilder{pool: pool}}
}

func (b *Int32BufferBuilder) AppendValues(data []int32) { b.Append(Int32Traits{}.CastToBytes(data)) }
func (b *Int32BufferBuilder) Values() []int32           { return Int32Traits{}.CastFromBytes(b.Bytes()) }
func (b *Int32BufferBuilder) Value(i int) int32         { return b.Values()[i] }
func (b *Int32BufferBuilder) Len() int                  { return b.length / int32SizeBytes }

func (b *Int32BufferBuilder) AppendValue(v int32) {
	if b.capacity < b.length+int32SizeBytes {
		newCapacity := nextPowerOf2(b.length + int32SizeBytes)
		b.resize(newCapacity)
	}
	Int32Traits{}.PutValue(b.bytes[b.length:], v)
	b.length += int32SizeBytes
}

type Int64BufferBuilder struct {
	bufferBuilder
}

func NewInt64BufferBuilder(pool memory.Allocator) *Int64BufferBuilder {
	return &Int64BufferBuilder{bufferBuilder: bufferBuilder{pool: pool}}
}

func (b *Int64BufferBuilder) AppendValues(data []int64) { b.Append(Int64Traits{}.CastToBytes(data)) }
func (b *Int64BufferBuilder) Values() []int64           { return Int64Traits{}.CastFromBytes(b.Bytes()) }
func (b *Int64BufferBuilder) Value(i int) int64         { return b.Values()[i] }
func (b *Int64BufferBuilder) Len() int                  { return b.length / int64SizeBytes }

func (b *Int64BufferBuilder) AppendValue(v int64) {
	if b.capacity < b.length+int64SizeBytes {
		newCapacity := nextPowerOf2(b.length + int64SizeBytes)
		b.resize(newCapacity)
	}
	Int64Traits{}.PutValue(b.bytes[b.length:], v)
	b.length += int64SizeBytes
}

type Uint64BufferBuilder struct {
	bufferBuilder
}

func NewUint64BufferBuilder(pool memory.Allocator) *Uint64BufferBuilder {
	return &Uint64BufferBuilder{bufferBuilder: bufferBuilder{pool: pool}}
}

func (b *Uint64BufferBuilder) AppendValues(data []uint64) { b.Append(Uint64Traits{}.CastToBytes(data)) }
func (b *Uint64BufferBuilder) Values() []uint64           { return Uint64Traits{}.CastFromBytes(b.Bytes()) }
func (b *Uint64BufferBuilder) Value(i int) uint64         { return b.Values()[i] }
func (b *Uint64BufferBuilder) Len() int                   { return b.length / uint64SizeBytes }

func (b *Uint64BufferBuilder) AppendValue(v uint64) {
	if b.capacity < b.length+uint64SizeBytes {
		newCapacity := nextPowerOf2(b.length + uint64SizeBytes)
		b.resize(newCapacity)
	}
	Uint64Traits{}.PutValue(b.bytes[b.length:], v)
	b.length += uint64SizeBytes
}

type Float64BufferBuilder struct {
	bufferBuilder
}

func NewFloat64BufferBuilder(pool memory.Allocator) *Float64BufferBuilder {
	return &Float64BufferBuilder{bufferBuilder: bufferBuilder{pool: pool}}
}

func (b *Float64BufferBuilder) AppendValues(data []float64) {
	b.Append(Float64Traits{}.CastToBytes(data))
}
func (b *Float64BufferBuilder) Values() []float64   { return Float64Traits{}.CastFromBytes(b.Bytes()) }
func (b *Float64BufferBuilder) Value(i int) float64 { return b.Values()[i] }
func (b *Float64BufferBuilder) Len() int            { return b.length / float64SizeBytes }

func (b *Float64BufferBuilder) AppendValue(v float64) {
	if b.capacity < b.length+float64SizeBytes {
		newCapacity := nextPowerOf2(b.length + float64SizeBytes)
		b.resize(newCapacity)
	}
	Float64Traits{}.PutValue(b.bytes[b.length:], v)
	b.length += float64SizeBytes
}
